<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Debugging</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #ffffff;
        color: #a0a0a0;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
    div.sourceCode
      { color: #1f1c1b; background-color: #ffffff; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #1f1c1b; } /* Normal */
    code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
    code span.an { color: #ca60ca; } /* Annotation */
    code span.at { color: #0057ae; } /* Attribute */
    code span.bn { color: #b08000; } /* BaseN */
    code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
    code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #924c9d; } /* Char */
    code span.cn { color: #aa5500; } /* Constant */
    code span.co { color: #898887; } /* Comment */
    code span.cv { color: #0095ff; } /* CommentVar */
    code span.do { color: #607880; } /* Documentation */
    code span.dt { color: #0057ae; } /* DataType */
    code span.dv { color: #b08000; } /* DecVal */
    code span.er { color: #bf0303; text-decoration: underline; } /* Error */
    code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
    code span.fl { color: #b08000; } /* Float */
    code span.fu { color: #644a9b; } /* Function */
    code span.im { color: #ff5500; } /* Import */
    code span.in { color: #b08000; } /* Information */
    code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
    code span.op { color: #1f1c1b; } /* Operator */
    code span.ot { color: #006e28; } /* Other */
    code span.pp { color: #006e28; } /* Preprocessor */
    code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #ff5500; } /* SpecialString */
    code span.st { color: #bf0303; } /* String */
    code span.va { color: #0057ae; } /* Variable */
    code span.vs { color: #bf0303; } /* VerbatimString */
    code span.wa { color: #bf0303; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  
  <link rel="icon" type="image/x-icon" href="favicon.ico">

</head>
<body>
<div class=wrapper>
<p>
csc 510-001, (1877)<br>
fall 2024, software engineering<br>
Tim Menzies, timm@ieee.org, com sci, nc state
<hr>
<a href="index.html">home</a>
:: <a href="syllabus.html">syllabus</a>
:: <a href="https://docs.google.com/spreadsheets/d/17AdVB6rGsKSf8Ut6gG5RD01IngOLjQvVxFdkSS76cYY/edit?usp=sharing">corpus</a> 
:: <a href="https://docs.google.com/spreadsheets/d/1as_d35pZSKT1zcVWEcqa59AaU7AmNYHpDvdlkdgaCdI/edit?gid=0#gid=0">groups</a> 
:: <a href="https://moodle-courses2425.wolfware.ncsu.edu/course/view.php?id=4180&bp=s">moodle</a>
:: <a href="https://github.com/txt/se24fall/blob/main/LICENSE">license</a>  </p>
<img src="img/banner.png" align=left width=280
style="padding: 10px; padding-right: 15px; -webkit-filter: drop-shadow(-10px 10px 10px #222); filter: drop-shadow(-10px 10px 10px #222); ">


<header id="title-block-header">
<h1 class="title">Debugging</h1>
</header>
<p><br clear=all></p>
<p>Important Links:<br />
<a
href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a><br />
<a
href="https://missing.csail.mit.edu/2020/debugging-profiling/">https://missing.csail.mit.edu/2020/debugging-profiling/</a><br />
<a
href="https://txt.github.io/se24fall/03code.html">https://txt.github.io/se24fall/03code.html</a></p>
<p>References:<br />
Brian Marick, “How to Misuse Code Coverage,” <a
href="http://www.exampler.com/testingcom/writings/coverage.pdf">http://www.exampler.com/testingcom/writings/coverage.pdf</a>
[1]</p>
<p>Ayewah, Pugh, Hovemeyer, Morgenthaler, Penix, “Using Static Analysis
to Find Bugs,” IEEE Software, vol. 25, no. 5, 2008. [2]</p>
<h2 id="debugging">Debugging</h2>
<p><strong>Debugging:</strong> The process by which a programmer
detects, and reproduces a software fault.</p>
<p>Please download the files debugging.py for use in the following
sections. Most of this debugging tutorial will be done using UNIX
commands. If you are on a windows machine, please install Windows
Subsystem for Linux (WSL) and use that to execute the commands in the
walkthrough.</p>
<h3 id="debugging-using-print-statements-logging">Debugging using print
statements, logging</h3>
<p>debugging.py is supposed to perform selection sort on an array of
integers, passed into the function as the variable arr.<br />
<strong>def selectionSort(arr):</strong><br />
<strong>n = len(arr)</strong><br />
<strong>for i in range(n):</strong><br />
<strong>lowestIndex = i</strong><br />
<strong>for j in range(n):</strong><br />
<strong>if arr[j] &lt; arr[lowestIndex]:</strong><br />
<strong>lowestIndex = j</strong></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>   <span class="op">**</span>arr\[lowestIndex\] \<span class="op">=</span> arr\[i\]<span class="op">**</span>  </span>
<span id="cb1-2"><a href="#cb1-2"></a>   <span class="op">**</span>arr\[i\] \<span class="op">=</span> arr\[lowestIndex\]<span class="op">**</span>  </span>
<span id="cb1-3"><a href="#cb1-3"></a>   <span class="op">**</span>n \<span class="op">=</span> n \<span class="op">-</span> <span class="dv">1</span><span class="op">**</span></span></code></pre></div>
<p><strong>return arr</strong></p>
<p><strong>arr_in = [5, 3, 2, 1, 8, 10, 11, 9, 23]</strong></p>
<p><strong>arr_out = selectionSort(arr_in)</strong></p>
<p><strong>print(arr_out)</strong></p>
<p>If you’ve finished Homework 1, you should have python3.13 installed.
To run debugging.py,<br />
copy it to a work_dir folder, and run the following command in your
command line:<br />
~/work_dir$ chmod u+x debugging.py<br />
~/work_dir$ python3.13 debugging.py<br />
[23, 11, 8, 5, 8, 10, 11, 9, 23]</p>
<p>Unfortunately, our selection sort has a bug in it, as the array the
program output is not in sorted order. How could we go about finding our
bug?</p>
<p><strong>Print debugging</strong><br />
The first and easiest solution most of us think of is to print out the
state of the array after every operation that affects the array. With
enough print statements, we’ll be able to pinpoint at what point in the
algorithm something unexpected occurs. Let’s augment our previous
version of debugging.py to include print statements.</p>
<p>def selectionSort(arr):<br />
n = len(arr)<br />
for i in range(n):<br />
lowestIndex = i<br />
for j in range(n):<br />
if arr[j] &lt; arr[lowestIndex]:<br />
lowestIndex = j</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>   <span class="bu">print</span>(<span class="st">&quot;lowest index &quot;</span>, lowestIndex) \<span class="co"># what index contains the lowest value?  </span></span>
<span id="cb2-2"><a href="#cb2-2"></a>   <span class="bu">print</span>(<span class="st">&quot;i &quot;</span>, i) \<span class="co"># where in the array should the ith smallest value be?  </span></span>
<span id="cb2-3"><a href="#cb2-3"></a>   <span class="bu">print</span>(<span class="st">&quot;n &quot;</span>, n) \<span class="co"># where are we considering the end of the array?</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>   <span class="bu">print</span>(<span class="st">&quot;before &quot;</span>, arr) \<span class="co"># what is array state before we swap anything?  </span></span>
<span id="cb2-6"><a href="#cb2-6"></a>   arr\[lowestIndex\] \<span class="op">=</span> arr\[i\]  </span>
<span id="cb2-7"><a href="#cb2-7"></a>   <span class="bu">print</span>(<span class="st">&quot;first &quot;</span>, arr) \<span class="co"># what is array state after the first write?  </span></span>
<span id="cb2-8"><a href="#cb2-8"></a>   arr\[i\] \<span class="op">=</span> arr\[lowestIndex\]  </span>
<span id="cb2-9"><a href="#cb2-9"></a>   <span class="bu">print</span>(<span class="st">&quot;final&quot;</span>, arr) \<span class="co"># what is array state after the second write?  </span></span>
<span id="cb2-10"><a href="#cb2-10"></a>   n \<span class="op">=</span> n \<span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
<p>return arr</p>
<p>Adding print statements to the code serves as a good exercise of
whether you understand the code you’ve written. My methodology for
adding print statements is as follows:</p>
<ol type="1">
<li>Print any variable that changes
<ol type="1">
<li>lowestIndex, i, n<br />
</li>
</ol></li>
<li>Print data structures before changes, and after changes
<ol type="1">
<li>Arr<br />
</li>
</ol></li>
<li>Comment all of your print statements to explain what each value /
change represents</li>
</ol>
<p>In this example, we do not need to print j, as it is captured in
lowestIndex, and only used to determine lowestIndex.<br />
Upon executing our new debugging.py, you’ll immediately notice that the
output was much longer than before, probably causing your shell window
to scroll downwards. While print debugging can be useful, working with
the artifacts of it, specifically text on the command line, can be
difficult, and is prone to accidental loss. If we wanted to save our
print statements to a file for ease of use, we can use the python
logging library.</p>
<p>The important difference between printing to stdout / stderr, and
using a logger to write to a log file, is that in many of the services
you’ll be deploying in this course, prints to stdout / stderr are not
captured in any way. When you print to a log file, you can either have
another service that consumes your logs and sends them to a centralized
database (ex. ElasticSearch), or you can remote directly into the server
that is hosting your service, and download the log files from the
server. Let’s examine our debugging.py, but with all of the print
statements rewritten to use python’s logging library.</p>
<p>import logging, sys<br />
logging.basicConfig(filename=‘debugging.log’, encoding=‘utf-8’,
level=logging.DEBUG, format=‘%(asctime)s %(message)s’)<br />
logging.debug(“NEW LOG”)</p>
<p>def selectionSort(arr):<br />
logger = logging.getLogger(__name__)<br />
n = len(arr)<br />
for i in range(n):<br />
lowestIndex = i<br />
for j in range(n):<br />
if arr[j] &lt; arr[lowestIndex]:<br />
lowestIndex = j</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>   logger.debug(<span class="st">&quot;lowest index: </span><span class="sc">%r</span><span class="st">&quot;</span>, lowestIndex) \<span class="co"># index w/ lowest value  </span></span>
<span id="cb3-2"><a href="#cb3-2"></a>   logger.debug(<span class="st">&quot;i: </span><span class="sc">%r</span><span class="st">&quot;</span>, i) \<span class="co"># ith smallest index  </span></span>
<span id="cb3-3"><a href="#cb3-3"></a>   logger.debug(<span class="st">&quot;n: </span><span class="sc">%r</span><span class="st">&quot;</span>, n) \<span class="co"># end of array</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a>   logger.debug(<span class="st">&quot;before: </span><span class="sc">%r</span><span class="st">&quot;</span>, arr) \<span class="co"># array state before we swap anything?  </span></span>
<span id="cb3-6"><a href="#cb3-6"></a>   arr\[lowestIndex\] \<span class="op">=</span> arr\[i\]  </span>
<span id="cb3-7"><a href="#cb3-7"></a>   logger.debug(<span class="st">&quot;first: </span><span class="sc">%r</span><span class="st">&quot;</span>, arr) \<span class="co"># state after the first change?  </span></span>
<span id="cb3-8"><a href="#cb3-8"></a>   arr\[i\] \<span class="op">=</span> arr\[lowestIndex\]</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a>   logger.debug(<span class="st">&quot;final: </span><span class="sc">%r</span><span class="st">&quot;</span>, arr) \<span class="co"># array state after the second change?  </span></span>
<span id="cb3-11"><a href="#cb3-11"></a>   n \<span class="op">=</span> n \<span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
<p>return arr</p>
<p>The update to use loggers was relatively simple; the print statements
have been replaced with calls to logger.debug, and the basic logging
configuration needed to be set up. For our logger, I’ve set it to output
to debugging.log, encoded the output in utf-8, and changed the output
format to prepend the ascii time to all messages. Let’s re-run our code
and examine the output. Since we are working with log files and not
command line output, it is easy to leave comments on the file to help
facilitate your understanding of the log.</p>
<p>~/work_dir$ python3.13 debugging.py<br />
~/work_dir$ cat debugging.py</p>
<p>2024-08-27 11:34:14,335 NEW LOG<br />
lowest index 3<br />
i 0<br />
n 9<br />
before [5, 3, 2, 1, 8, 10, 11, 9, 23]<br />
first [5, 3, 2, 5, 8, 10, 11, 9, 23] ### 5 is swapped from index 0 into
index 3<br />
final [5, 3, 2, 5, 8, 10, 11, 9, 23] ### 5 is swapped from index 3 into
index 0<br />
lowest index 2<br />
i 1<br />
n 8 ### why are not considering the last element (23) of the
array?<br />
before [5, 3, 2, 5, 8, 10, 11, 9, 23]<br />
first [5, 3, 3, 5, 8, 10, 11, 9, 23] ### 3 is swapped from index 2 into
index 1<br />
final [5, 3, 3, 5, 8, 10, 11, 9, 23] ### 3 is swapped from index 1 into
index 2</p>
<p>As the inline comments call out, the first operation that edits the
array, arr[lowestIndex] = arr[i], is causing the element in
arr[lowestIndex] to be overwritten by the element in arr[i]. This can be
easily fixed by saving arr[lowestIndex] into a temporary variable, and
then writing that temporary variable into arr[i]. Let’s update the code
to use a temporary variable, then re-examine our output.</p>
<p>import logging, sys<br />
logging.basicConfig(filename=‘partial_debugging.log’, encoding=‘utf-8’,
level=logging.DEBUG, format=‘%(asctime)s %(message)s’)<br />
logging.debug(“NEW LOG”)</p>
<p>def selectionSort(arr):<br />
logger = logging.getLogger(__name__)<br />
n = len(arr)<br />
for i in range(n):<br />
lowestIndex = i<br />
for j in range(n):<br />
if arr[j] &lt; arr[lowestIndex]:<br />
lowestIndex = j</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>   logger.debug(<span class="st">&quot;lowest index: </span><span class="sc">%r</span><span class="st">&quot;</span>, lowestIndex) \<span class="co"># what index contains the lowest value?  </span></span>
<span id="cb4-2"><a href="#cb4-2"></a>   logger.debug(<span class="st">&quot;i: </span><span class="sc">%r</span><span class="st">&quot;</span>, i) \<span class="co"># where in the array should the ith smallest value be?  </span></span>
<span id="cb4-3"><a href="#cb4-3"></a>   logger.debug(<span class="st">&quot;n: </span><span class="sc">%r</span><span class="st">&quot;</span>, n) \<span class="co"># where are we considering the end of the array?</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a>   lowestNum \<span class="op">=</span> arr\[lowestIndex\]</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>   logger.debug(<span class="st">&quot;lowestNum: </span><span class="sc">%r</span><span class="st">&quot;</span>,lowestNum) \<span class="co"># lowest number found in unsorted array</span></span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>   logger.debug(<span class="st">&quot;before: </span><span class="sc">%r</span><span class="st">&quot;</span>, arr) \<span class="co"># array state before we swap anything  </span></span>
<span id="cb4-10"><a href="#cb4-10"></a>   arr\[lowestIndex\] \<span class="op">=</span> arr\[i\]  </span>
<span id="cb4-11"><a href="#cb4-11"></a>   logger.debug(<span class="st">&quot;first: </span><span class="sc">%r</span><span class="st">&quot;</span>, arr) \<span class="co"># array state after the first change  </span></span>
<span id="cb4-12"><a href="#cb4-12"></a>   arr\[i\] \<span class="op">=</span> lowestNum</span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a>   logger.debug(<span class="st">&quot;final: </span><span class="sc">%r</span><span class="st">&quot;</span>, arr) \<span class="co"># array state after the second change  </span></span>
<span id="cb4-15"><a href="#cb4-15"></a>   n \<span class="op">=</span> n \<span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
<p>return arr</p>
<p>~/work_dir$ python3.13 debugging.py<br />
[23, 10, 5, 8, 1, 2, 3, 9, 11]</p>
<p>Unfortunately, even though we fixed a bug, our program actually had
multiple bugs! And while this process of adding logging to our file has
been useful to record unexpected behavior for later examination, it has
reduced the readability of the algorithm, and required editing our code
and re-executing it after every change. As shown by this exercise,
logging is best added AS YOU WRITE THE CODE, and not after the fact.
Logging is best used to capture specific, important lines of output from
your code that you can use for diagnosing and solving bugs in your code
AFTER they have happened.</p>
<p>What we really want to find our final bug in debugging.py is the
ability to step through our code line by line, and inspect the contents
of all of the variables and arrays as the unexpected behavior occurs.
Python provides <strong>PDB</strong>, a debugger for the python
programming language that is included in your installation of
python3.13. Let’s cover how we can use <strong>PDB</strong> to find our
bug more efficiently than using print statements and inspecting
logs.</p>
<h3 id="debugging-with-pdb">Debugging with PDB</h3>
<p><strong>Debugger:</strong> A program that allows you to interact with
the execution of a program. Most if not all programming languages come
with a debugger. Debuggers typically provide the following ways of
interacting with a program:</p>
<ul>
<li>Placing <strong>breakpoints</strong> to halt execution of the
program when it reaches a certain line<br />
</li>
<li>Stepping through the program one instruction at a time<br />
</li>
<li>Inspecting values of variables during execution and after the
program has crashed<br />
</li>
<li>Conditionally halt the execution of the program when a given
condition is met.</li>
</ul>
<p><strong>PDB:</strong> Debugger for the Python programming language.
Included in python.<br />
To use <strong>PDB</strong> in debugging.py, import pdb, and add a call
to breakpoint() on the line of code you’d like the debugger to stop
execution on:</p>
<p>import pdb<br />
def selectionSort(arr):<br />
n = len(arr)<br />
for i in range(n):<br />
lowestIndex = i<br />
for j in range(n):<br />
if arr[j] &lt; arr[lowestIndex]:<br />
lowestIndex = j</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource python numberLines"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>   <span class="bu">breakpoint</span>()  </span>
<span id="cb5-2"><a href="#cb5-2"></a>   lowestNum \<span class="op">=</span> arr\[lowestIndex\]  </span>
<span id="cb5-3"><a href="#cb5-3"></a>   arr\[lowestIndex\] \<span class="op">=</span> arr\[i\]  </span>
<span id="cb5-4"><a href="#cb5-4"></a>   arr\[i\] \<span class="op">=</span> lowestNum</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a>   n \<span class="op">=</span> n \<span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
<p>return arr</p>
<p>Now when you execute debugging.py, you’ll be prompted with the pdb
debugger, indicated by the (pdb) on your command line. To display code
11 lines above and below the breakpoint, enter l (l as in list).<br />
~/work_dir$ python3.13 debugging.py<br />
&gt;
/home/ubuntu/Home/PHD/tacsc510/pdb_partial_debugging.py(11)selectionSort()<br />
-&gt; breakpoint()<br />
(Pdb) l<br />
6 lowestIndex = i<br />
7 for j in range(n):<br />
8 if arr[j] &lt; arr[lowestIndex]:<br />
9 lowestIndex = j<br />
10<br />
11 -&gt; breakpoint()<br />
12 lowestNum = arr[lowestIndex]<br />
13 arr[lowestIndex] = arr[i]<br />
14 arr[i] = lowestNum<br />
15<br />
16 n = n - 1</p>
<p>Now we have loaded our program into PDB and stopped its execution, we
have many options in interacting with our stalled program. Here are the
main commands you should know:</p>
<ul>
<li><strong>l</strong>(ist): Displays 11 lines around the current line
or continue the previous listing<br />
</li>
<li><strong>s</strong>(tep): Execute the current line, stop at the first
possible location<br />
</li>
<li><strong>n</strong>(ext): Continue execution until the next line in
the current function is reached or it returns<br />
</li>
<li><strong>b</strong>(reak): set a breakpoint<br />
</li>
<li><strong>p</strong>(rint): Evaluate the expression in the current
context and print its value<br />
</li>
<li><strong>r</strong>(eturn): Continue execution until the current
function returns<br />
</li>
<li><strong>q(</strong>uit) - Quit the debugger</li>
</ul>
<p>Below is an attached video of using pdb to step through debugging.py
and find the remaining bug:</p>
<p>&lt;Insert video here&gt;</p>
<h2 id="static-analysis">Static Analysis</h2>
<p><strong>Static Analysis:</strong> the process of evaluating a system
or component based on its form, structure, content or documentation.
Does <strong>NOT</strong> involve the execution of the program. Searches
through code to detect bug patterns and security vulnerabilities.</p>
<p><strong>Why do we statically analyze our code?</strong> To find
faults in our programs without executing the code. Code inspection can
identify where code may not meet specifications or where recommended
programming practices are being broken. Well tested code written by
experts often has a surprising number of obvious bugs that can be found
via automated static analysis, without wasting time and money on a test
deployment. [2] Static analysis tools serve an important role in
cataloging and raising awareness of developers about subtle correctness
issues that lead to future bug prevention. [2]</p>
<p>For debugging.py, the truth of the matter is that both bugs could be
found via static analysis tools, without ever needing to run our code.
Let’s review a few of the most useful static analysis tools for
python:</p>
<ul>
<li><a href="https://pypi.org/project/pyflakes">pyflakes</a>: Checks a
python source file for errors that would cause the program to fail
during execution<br />
</li>
<li><a href="https://github.com/Microsoft/pyright">pyright</a>: Static
type checker for python<br />
</li>
<li><a href="https://pylint.readthedocs.io/en/latest/">pylint</a>: Looks
for programming errors, helps enforce a coding standard, finds code
smells, which are indications of deeper problems in a system<br />
</li>
<li><a href="https://pypi.org/project/autopep8/">Autopep8</a> -
Automatically formats python code to conform to the PEP 8 style
guide.<br />
</li>
<li><a href="https://bandit.readthedocs.io/en/latest/">Bandit</a> -
Finds common security issues in python code</li>
</ul>
<h2 id="software-testing">Software Testing</h2>
<p><strong>Testing:</strong> The process of finding software faults via
<strong>dynamic verification</strong> of the behavior of a program, on a
finite set of test cases, suitably selected, against the expected
behavior. Involves the execution of the program.</p>
<p><strong>Fault:</strong> as an incorrect step, process, or data
definition in a program.</p>
<p><strong>Why do we test?</strong> Without testing, you don’t know if
your program actually behaves as expected. Before writing dedicated test
cases, you may have only passed a tiny amount of inputs through your
system, and only seen a tiny amount of outputs. Testing is the process
of selecting good representative inputs for all possible interactions in
your program and seeing whether they map to the expected output . Good
tests provide a lens into how the program is working, and allow you to
find software faults when they fail unexpectedly.</p>
<p><strong>Test Case:</strong> Defines an individual test against a
software system. Defines an input to the system and the expected output.
Can be done at a high level against the entire software system, or at a
low level against code units like methods classes.</p>
<p><strong>White-box testing:</strong> Writing tests with full
understanding of the code. Tests are focused on exercising all code
paths; logical decisions as both true and false, loops at their
boundaries, and context-dependent testing of internal data
structures.</p>
<p><strong>Black-box testing:</strong> Writing tests while ignoring the
internals of the program. Tests are focused on whether inputs produce
expected outputs dictated by customer requirements.</p>
<p><strong>Unit Testing:</strong> Testing of individual hardware or
software units or groups of related units. Test cases consist of
individual methods, interleaved methods, or classes. Done by programmers
as white-box testing. Automation of unit testing is desired for
consistency and ease of repeatability.</p>
<p><strong>System Testing:</strong> Testing conducted on a complete,
integrated system to evaluate the system compliance with its specified
requirements. Test cases are generated from analyzing customer
requirements, and can be written before the system has even begun
development. As system testing is black box, testing is often done by an
external test group and not the programmers, as too much knowledge of
the code can result in a lack of breadth in test cases.</p>
<p><strong>Verification:</strong> Are we building the product right?
Done via white-box testing<br />
<strong>Validation:</strong> Are we building the right product? Done via
black-box testing</p>
<p><strong>Code Coverage:</strong> A measure of test case
completeness.</p>
<ul>
<li><p><strong>Method Coverage:</strong> Have all methods been
called?<br />
</p></li>
<li><p><strong>Statement Coverage:</strong> Have all the statements in a
method been executed?<br />
</p></li>
<li><p><strong>Decision/Branch Coverage:</strong> Have all decisions
been executed in both the true and false paths?<br />
</p></li>
<li><p><strong>Condition Coverage:</strong> Have all conditionals been
executed in both the true and false paths?</p>
<p><strong>Limitation of Code Coverage:</strong> The assumption that you
are done testing if you have high coverage is incorrect. Coverage only
tells you if you’ve covered the code that’s been written. There may be
requirements you have missed while writing your code, which cannot be
discovered via code coverage. [1]</p>
<p><strong>Test-driven Design:</strong> Writing your test cases
<strong>BEFORE</strong> you write the code that the case will
test.</p></li>
</ul>
<h2 id="exercises">Exercises</h2>
<ol type="1">
<li>Execute at least <strong>three</strong> of the static analysis tools
on hw2_debugging.py
<ol type="1">
<li>Hw2_debugging.py consists of an implementation of mergeSort that
uses multiple helper methods to sort the array
<ol type="1">
<li>For each tool you run, save the trace created by the tool in a
folder called ‘pre_traces’<br />
</li>
<li>Make all of the code changes the static analysis tools
recommend.<br />
</li>
<li>Re-run each tool, save the trace created by the tool in a folder
called ‘post_traces’<br />
</li>
</ol></li>
<li>Write test cases to verify your merge sort works, that should be
executable via pytest.
<ol type="1">
<li>Provide a README.md that details how to run your test</li>
</ol></li>
</ol></li>
</ol>




</div>
</body>
</html>
